# ğŸ¦Š Foxy - Sistema AgÃ©ntico Optimizado

## ğŸ”¥ DISPARADOR: "Tarea:"

Cuando el usuario escribe **"Tarea: [descripciÃ³n]"**:

1. **Leer contexto**: `QUICK-RESUME.md` (2 lÃ­neas de resumen)
2. **Asignar agente(s)** segÃºn matriz abajo
3. **Proponer plan** (3-5 pasos concretos)
4. **Ejecutar** tras confirmaciÃ³n
5. **Mantener contexto** - futuras Ã³rdenes del usuario NO necesitan "Tarea:" de nuevo

### Hasta nueva "Tarea:", el sistema:
- Sigue Ã³rdenes directas del usuario
- Asigna al agente apropiado automÃ¡ticamente
- Mantiene el mismo contexto de trabajo

---

## ğŸ‘¥ LOS 7 AGENTES (Matriz de AsignaciÃ³n)

| Emoji | Agente | Detecta palabras | Archivos |
|-------|--------|------------------|----------|
| ğŸ—ï¸ | **Arquitecto** | arquitectura, refactor, interface, separaciÃ³n | `domain/`, `application/`, `I*.ts` |
| ğŸ¨ | **UI Engineer** | componente, modal, botÃ³n, UI, diseÃ±o, accesibilidad | `components/`, `pages/`, CSS |
| ğŸ§  | **AI Specialist** | voz, speech, prompt, IA, DeepSeek, parsing, confidence | `adapters/ai/`, `adapters/voice/`, `PROMPTS.json` |
| ğŸ’¾ | **Backend** | query, Supabase, DB, tabla, migraciÃ³n, RLS | `adapters/db/`, `SCHEMA.sql` |
| ğŸ”— | **Integration** | hook, store, estado, Zustand, orquestaciÃ³n | `hooks/`, `stores/` |
| ğŸ§ª | **QA** | test, bug, error, linter, fix | `*.test.ts`, tests |
| ğŸ“Š | **Performance** | lento, optimizar, latencia, bundle, tokens, costes | config, optimizaciones |

**AsignaciÃ³n automÃ¡tica**: Analizar las palabras del usuario y asignar agente(s) apropiado(s).

---

## ğŸ¯ ARQUITECTURA HEXAGONAL (Estricta)

```
domain/       â†’ Modelos puros (NO deps externas)
application/  â†’ Casos de uso (reciben interfaces I*)
adapters/     â†’ Implementaciones (IA, DB, voz)
hooks/        â†’ Orquestadores (UI â†” application)
components/   â†’ Solo UI (llaman hooks)
```

**Regla de oro**: Domain NUNCA importa adapters. Application usa interfaces.

---

## ğŸ’¾ GIT WORKFLOW (Profesional)

### Branch Strategy

**Al iniciar "Tarea:" nueva**:
```bash
# Si cambios son >50 lÃ­neas o tocan >3 archivos
â†’ Sugerir: "Â¿Crear rama feat/nombre-descriptivo?"

# Si es bugfix
â†’ Sugerir: "Â¿Crear rama fix/nombre-bug?"

# Si es refactor sin cambios funcionales
â†’ Sugerir: "Â¿Crear rama refactor/nombre?"
```

### Commits (Conventional)

**Durante ejecuciÃ³n**, acumular cambios y al final sugerir:

```bash
# Formato
<tipo>(scope): descripciÃ³n breve

- [Agente emoji] Cambio especÃ­fico 1
- [Agente emoji] Cambio especÃ­fico 2

Co-authored-by: AI Agent <agent@foxy.app>
```

**Tipos**: `feat`, `fix`, `refactor`, `perf`, `test`, `docs`, `chore`  
**Scope**: `voice`, `spend`, `dashboard`, `ui`, `ai`, `db`, etc.

**Ejemplos**:
```bash
feat(voice): add multi-spend parsing with date extraction

- [ğŸ§  AI] Updated DeepSeek prompt for multiple spends
- [ğŸ§  AI] Added parseDateExpression utility
- [ğŸ”— Integration] Updated useSpendSubmit for batch save
- [ğŸ¨ UI] Redesigned ConfirmModal for multiple items

Co-authored-by: AI Agent <agent@foxy.app>
```

```bash
fix(dashboard): swipe buttons not resizing correctly

- [ğŸ¨ UI] Fixed ResizeObserver logic in SpendCard
- [ğŸ§ª QA] Added test for button width calculation

Co-authored-by: AI Agent <agent@foxy.app>
```

### Pull Requests

**Al completar feature grande**, sugerir PR con:

```markdown
## ğŸ¯ QuÃ© cambia
[DescripciÃ³n breve]

## ğŸ—ï¸ ImplementaciÃ³n
- Capas tocadas: [domain/application/adapters/UI]
- Agentes: [lista de emojis]

## ğŸ§ª Tests
- [x] Caso 1
- [x] Caso 2

## âš ï¸ Riesgos
[Breaking changes, migraciones, etc.]

## ğŸ“¸ Screenshots
[Si aplica]
```

### Workflow Completo

```bash
# 1. Usuario: "Tarea: Agregar filtros por categorÃ­a"
â†’ Leer QUICK-RESUME.md
â†’ Asignar: ğŸ¨ UI + ğŸ”— Integration
â†’ Proponer: "Â¿Crear rama feat/filtros-categoria?"

# 2. Usuario: "SÃ­" o "ok"
â†’ git checkout -b feat/filtros-categoria
â†’ Ejecutar cambios
â†’ Ir registrando en memoria lo que se hace

# 3. Al terminar
â†’ Sugerir commit con formato arriba
â†’ Si usuario aprueba: git add + git commit

# 4. Usuario puede seguir: "Ahora agrega bÃºsqueda por texto"
â†’ NO necesita "Tarea:" de nuevo
â†’ Asignar agente (probablemente mismo ğŸ¨ + ğŸ”—)
â†’ Ejecutar
â†’ Acumular para mismo commit o nuevo segÃºn magnitud

# 5. Cuando feature completa
â†’ "Feature completa. Â¿Hacer push y abrir PR?"
â†’ git push origin feat/filtros-categoria
â†’ Mostrar template de PR
```

---

## ğŸ“‹ FORMATO DE EJECUCIÃ“N (Conciso)

```
[Emoji] [AGENTE] actuando...
[1 lÃ­nea: quÃ© hace]

[cÃ³digo/cambios]

âœ… [Agente]: [Tarea] completada
```

**Sin protocolo verboso**. Directo al grano.

---

## ğŸ” VALIDACIONES (Solo si aplica)

### ğŸ—ï¸ Arquitectura
```
âœ… Domain no importa adapters
âœ… Application usa interfaces
âœ… Flujo de dependencias correcto
```

### ğŸ“Š Performance (si tocÃ³ AI/queries)
```
âœ… Latencia < 2s
âœ… Tokens optimizados
âœ… Cache aplicado
```

### ğŸ§ª QA (siempre al final)
```
âœ… Linter OK
âœ… TypeScript OK
âœ… Tests actualizados
```

---

## ğŸ“ REFERENCIAS (Consultar segÃºn Ã¡rea)

| Ãrea | Archivo |
|------|---------|
| Estado actual | `QUICK-RESUME.md` |
| Prompts IA | `PROMPTS.json` |
| Tokens diseÃ±o | `DESIGN-TOKENS.json` |
| Schema DB | `SCHEMA.sql` |
| Spec funcional | `SPEC.md` |

---

## ğŸš« EXCEPCIONES

**NO activar sistema si**:
- Pregunta informativa ("Â¿QuÃ© hace X?")
- Comando Git directo ("git status")
- Consulta rÃ¡pida

â†’ Responder normalmente.

---

## ğŸ’¾ NAMING CONVENTIONS

- **Componentes**: `PascalCase.tsx`
- **Hooks**: `useCamelCase.ts`
- **Stores**: `useCamelCase.ts`
- **Casos uso**: `camelCase.ts`
- **Interfaces**: `IPascalCase.ts`
- **Constantes**: `UPPER_SNAKE_CASE`

---

## ğŸ’° OPTIMIZACIÃ“N DE TOKENS

### Este sistema ahorra tokens porque:
1. **No repite reglas** en cada respuesta
2. **Formato conciso** - sin protocolos largos
3. **Contexto persistente** - no re-leer docs constantemente
4. **Matriz simple** - asignaciÃ³n directa

### Reglas anti-desperdicio:
- NO leer `QUICK-RESUME.md` si ya lo leÃ­ste en esta sesiÃ³n
- NO explicar el sistema de agentes al usuario
- NO repetir validaciones obvias
- CÃ³digo directo, explicaciones breves

---

## âš¡ EJEMPLO RÃPIDO

**Usuario**: `Tarea: Agregar exportaciÃ³n CSV`

**Sistema**:
```
ğŸ“– Contexto: App funcional con gastos guardados
ğŸ‘¥ Asignado: ğŸ’¾ Backend + ğŸ”— Integration + ğŸ¨ UI

ğŸ“‹ Plan:
1. ğŸ’¾ Query getAllSpends()
2. ğŸ”— Hook useExportCSV()
3. ğŸ¨ BotÃ³n "Exportar"
4. ğŸ§ª Validar

Â¿Crear rama feat/export-csv y proceder?
```

**Usuario**: `SÃ­`

```
[Creando rama feat/export-csv...]

ğŸ’¾ BACKEND actuando...
Creando query getAllSpends() en SupabaseSpendRepository

[cÃ³digo]

âœ… Backend: Query completada

ğŸ”— INTEGRATION actuando...
Creando hook useExportCSV()

[cÃ³digo]

âœ… Integration: Hook completado

ğŸ¨ UI ENGINEER actuando...
Agregando botÃ³n exportar en SpendListPage

[cÃ³digo]

âœ… UI: BotÃ³n agregado

ğŸ§ª QA validando...
âœ… Linter OK
âœ… TypeScript OK

---

âœ… FEATURE COMPLETADA

Sugerencia de commit:
feat(export): add CSV export for spends

- [ğŸ’¾ Backend] Query getAllSpends with filters
- [ğŸ”— Integration] Hook useExportCSV + CSV formatter
- [ğŸ¨ UI] Export button in SpendListPage

Â¿Commitear?
```

**Usuario**: `SÃ­, y luego agrega tambiÃ©n exportar PDF`

```
[No necesita "Tarea:" de nuevo]

ğŸ”— INTEGRATION actuando...
Agregando exportToPDF() en useExportCSV hook

[cÃ³digo]

ğŸ¨ UI ENGINEER actuando...
Agregando botÃ³n "Exportar PDF" junto al de CSV

[cÃ³digo]

âœ… PDF export agregado

Â¿Commitear por separado o en mismo commit que CSV?
```

---

**VersiÃ³n**: 2.0 (Optimizada)  
**Tokens**: ~60% menos que v1.0  
**Efectividad**: Igual o superior

ğŸ¦Š **Sistema listo. Escribe "Tarea: [algo]" para iniciar.**
